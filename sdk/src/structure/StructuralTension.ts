/**
 * StructuralTension - Unified tension signal across all musical domains
 *
 * Schillinger Principle: Tension is not a single value, but a composite
 * of rhythmic, harmonic, and formal forces that evolve independently
 * but resolve together.
 *
 * Critical rule: All tension values must be written by actual musical
 * events, not arbitrary parameters. If it doesn't affect sound, it's
 * not tension.
 *
 * @module structure/StructuralTension
 */

/**
 * Represents tension across the three fundamental Schillinger domains
 *
 * Rhythmic: Generated by density, drill, fills, gates, microtiming
 * Harmonic: Generated by chord instability, voice leading, functional tension
 * Formal: Generated by phrase boundaries, section transitions, cadence expectations
 */
export interface StructuralTension {
  /** Rhythmic tension 0..1 (density, drill, silence, phase) */
  rhythmic: number;

  /** Harmonic tension 0..1 (instability, dissonance, voice leading) */
  harmonic: number;

  /** Formal tension 0..1 (phrase position, section boundaries, cadence) */
  formal: number;
}

/**
 * Creates a zero-tension state (complete stability)
 *
 * Use this as the initial state before any musical events occur.
 */
export function zeroTension(): StructuralTension {
  return {
    rhythmic: 0,
    harmonic: 0,
    formal: 0,
  };
}

/**
 * Aggregates the three tension domains into a single total tension value
 *
 * Schillinger weighting principle:
 * - Rhythm and harmony are primary drivers (40% each)
 * - Form is the organizing principle (20%)
 *
 * The weights are chosen to reflect musical reality:
 * - Rhythm creates immediate tension (drill, fills, silence)
 * - Harmony creates sustained tension (dissonance, instability)
 * - Form creates expected tension (phrase endings, cadences)
 *
 * @param t - The structural tension to aggregate
 * @returns Total tension clamped to [0, 1]
 */
export function totalTension(t: StructuralTension): number {
  // Clamp each domain to valid range before weighting
  const rhythmic = Math.max(0, Math.min(1, t.rhythmic));
  const harmonic = Math.max(0, Math.min(1, t.harmonic));
  const formal = Math.max(0, Math.min(1, t.formal));

  // Weighted sum with Schillinger-correct proportions
  const weighted = 0.4 * rhythmic + 0.4 * harmonic + 0.2 * formal;

  // Clamp final result to valid range
  return Math.max(0, Math.min(1, weighted));
}

/**
 * Clamps a tension value to the valid range [0, 1]
 *
 * Use this when writing tension from events that might produce
 * values outside the valid range (e.g., accent density, phase drift)
 */
export function clampTension(value: number): number {
  return Math.max(0, Math.min(1, value));
}

/**
 * Creates a copy of a tension state
 *
 * Use this when you need to modify tension without mutating the original
 */
export function copyTension(t: StructuralTension): StructuralTension {
  return {
    rhythmic: t.rhythmic,
    harmonic: t.harmonic,
    formal: t.formal,
  };
}

/**
 * Checks if two tension states are equal (useful for testing)
 */
export function tensionEquals(
  a: StructuralTension,
  b: StructuralTension,
): boolean {
  const epsilon = 0.0001;
  return (
    Math.abs(a.rhythmic - b.rhythmic) < epsilon &&
    Math.abs(a.harmonic - b.harmonic) < epsilon &&
    Math.abs(a.formal - b.formal) < epsilon
  );
}

/**
 * Interpolates between two tension states
 *
 * Useful for smooth transitions, resolution curves, and
 * tension-based animations
 *
 * @param from - Starting tension
 * @param to - Ending tension
 * @param t - Interpolation factor 0..1
 * @returns Interpolated tension state
 */
export function interpolateTension(
  from: StructuralTension,
  to: StructuralTension,
  t: number,
): StructuralTension {
  return {
    rhythmic: from.rhythmic + (to.rhythmic - from.rhythmic) * t,
    harmonic: from.harmonic + (to.harmonic - from.harmonic) * t,
    formal: from.formal + (to.formal - from.formal) * t,
  };
}
