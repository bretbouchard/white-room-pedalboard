/**
 * Realization Engine - Derivation Record
 *
 * Tracks how every note was generated from theory parameters.
 * Enables explainable AI and round-trip reconciliation.
 */

import type { DerivationRecord_v1, DerivationOutput, ConstraintApplication } from "../types";

/**
 * Builder for creating derivation records
 */
export class DerivationRecordBuilder {
  private record: Partial<DerivationRecord_v1>;
  private outputs: Map<string, DerivationOutput>;
  private constraints: Map<string, ConstraintApplication>;
  private executionOrder: string[];

  constructor(songId: string, seed: number) {
    this.record = {
      derivationId: crypto.randomUUID(),
      sourceSongId: songId,
      seed,
      executionOrder: [],
      outputs: [],
      constraintsApplied: [],
    };
    this.outputs = new Map();
    this.constraints = new Map();
    this.executionOrder = [];
  }

  /**
   * Add a system to the execution order
   */
  addSystem(systemId: string): void {
    if (!this.executionOrder.includes(systemId)) {
      this.executionOrder.push(systemId);
    }
  }

  /**
   * Record output from a system
   */
  addOutput(output: DerivationOutput): void {
    this.outputs.set(output.systemId, output);
    if (!this.executionOrder.includes(output.systemId)) {
      this.executionOrder.push(output.systemId);
    }
  }

  /**
   * Add notes generated by a system
   */
  addNotes(systemId: string, noteIds: string[], parameters: Record<string, unknown>): void {
    this.addOutput({
      systemId,
      outputType: this.getOutputType(systemId),
      noteIds,
      parameters,
      constraints: [],
    });
  }

  /**
   * Record constraint application
   */
  addConstraint(constraint: ConstraintApplication): void {
    this.constraints.set(`${constraint.systemId}:${constraint.constraintId}`, constraint);
  }

  /**
   * Build the final derivation record
   */
  build(): DerivationRecord_v1 {
    return {
      ...this.record,
      executionOrder: [...this.executionOrder],
      outputs: Array.from(this.outputs.values()),
      constraintsApplied: Array.from(this.constraints.values()),
    } as DerivationRecord_v1;
  }

  /**
   * Infer output type from system ID
   */
  private getOutputType(systemId: string): DerivationOutput["outputType"] {
    if (systemId.startsWith("rhythm")) return "rhythm";
    if (systemId.startsWith("melody")) return "melody";
    if (systemId.startsWith("harmony")) return "harmony";
    if (systemId.startsWith("form")) return "form";
    if (systemId.startsWith("ensemble") || systemId.includes("voice")) return "orchestration";
    return "rhythm"; // default
  }
}

/**
 * Derivation context passed through realization
 *
 * Tracks which systems have executed and what outputs they produced.
 */
export class DerivationContext {
  private builder: DerivationRecordBuilder;
  private noteSources: Map<string, string>; // noteId -> systemId

  constructor(songId: string, seed: number) {
    this.builder = new DerivationRecordBuilder(songId, seed);
    this.noteSources = new Map();
  }

  /**
   * Get the builder
   */
  getBuilder(): DerivationRecordBuilder {
    return this.builder;
  }

  /**
   * Record note generation
   */
  recordNotes(systemId: string, noteIds: string[], parameters: Record<string, unknown>): void {
    this.builder.addNotes(systemId, noteIds, parameters);
    for (const noteId of noteIds) {
      this.noteSources.set(noteId, systemId);
    }
  }

  /**
   * Get which system generated a note
   */
  getNoteSource(noteId: string): string | undefined {
    return this.noteSources.get(noteId);
  }

  /**
   * Build final record
   */
  build(): DerivationRecord_v1 {
    return this.builder.build();
  }
}
