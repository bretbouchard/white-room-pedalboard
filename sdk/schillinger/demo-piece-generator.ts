/**
 * Demo Piece: Interference Study No. 1
 *
 * Canonical Schillinger demo piece that proves completeness through
 * structural necessity. If any subsystem is removed, the piece
 * audibly collapses.
 *
 * 64 bars, 130 BPM, 4/4 time
 * Form: A (Stability) → B (Interference) → C (Collapse) → A' (Resolution)
 *
 * @module schillinger/demo-piece
 */

import { TensionAccumulator } from "../src/structure/TensionAccumulator";
import { PhaseStateManager } from "../src/structure/PhaseState";
import {
  StructuralTension,
  totalTension,
} from "../src/structure/StructuralTension";
import {
  HarmonicAnalyzer,
  ChordQuality,
} from "../src/structure/HarmonicAnalyzer";

/**
 * Musical event generated by the demo piece
 */
export interface MusicalEvent {
  bar: number;
  beat: number;
  role: string;
  type: "note" | "rest" | "fill" | "drill" | "gate" | "phase_reset";
  properties: {
    pitch?: number;
    velocity?: number;
    duration?: number;
    phaseOffset?: number;
    density?: number;
  };
  tension: StructuralTension;
  cause: string;
}

/**
 * Demo piece configuration
 */
export interface DemoPieceConfig {
  tempo: number;
  timeSignature: [number, number];
  seed: number;
}

/**
 * Section boundaries
 */
enum Section {
  A_STABILITY = "A_STABILITY",
  B_INTERFERENCE = "B_INTERFERENCE",
  C_COLLAPSE = "C_COLLAPSE",
  A_RESOLUTION = "A_RESOLUTION",
}

/**
 * Generates the canonical demo piece "Interference Study No. 1"
 *
 * Usage:
 * ```typescript
 * const generator = new DemoPieceGenerator();
 * const events = generator.generate();
 * // events contains all musical events with tension tracking
 * ```
 */
export class DemoPieceGenerator {
  private tension: TensionAccumulator;
  private phase: PhaseStateManager;
  private harmonic: HarmonicAnalyzer;
  private config: DemoPieceConfig;
  private events: MusicalEvent[] = [];

  constructor(config?: Partial<DemoPieceConfig>) {
    this.tension = new TensionAccumulator();
    this.phase = new PhaseStateManager();
    this.harmonic = new HarmonicAnalyzer();
    this.config = {
      tempo: 130,
      timeSignature: [4, 4],
      seed: 42,
      ...config,
    };

    this.initializeRoles();
  }

  /**
   * Generate all 64 bars of the demo piece
   */
  generate(): MusicalEvent[] {
    this.events = [];

    // SECTION A: Stability (bars 1-16)
    this.generateSectionA();

    // SECTION B: Interference (bars 17-32)
    this.generateSectionB();

    // SECTION C: Collapse (bars 33-48)
    this.generateSectionC();

    // SECTION A': Resolution (bars 49-64)
    this.generateSectionAprime();

    return this.events;
  }

  /**
   * SECTION A: Stability (Bars 1-16)
   *
   * Purpose: Prove system can sound calm
   * Constraints: tension.total < 0.3
   */
  private generateSectionA(): void {
    // Bars 1-4: Groove only, tonic harmony
    for (let bar = 1; bar <= 4; bar++) {
      this.generateBar(bar, {
        groove: true,
        drill: 0,
        gate: false,
        fills: false,
        harmonicChord: { root: 60, type: "major" }, // C major tonic
        harmonicFunction: "tonic",
        expectedTension: 0.14, // 0.1 rhythmic + 0.1 harmonic
      });
    }

    // Bars 5-8: Light fills at bar 8 only
    for (let bar = 5; bar <= 8; bar++) {
      this.generateBar(bar, {
        groove: true,
        drill: bar === 8 ? 0.2 : 0,
        gate: false,
        fills: bar === 8,
        harmonicChord: { root: 60, type: "major" },
        harmonicFunction: "tonic",
        expectedTension: bar === 8 ? 0.18 : 0.14,
      });
    }

    // Bars 9-12: Subdominant motion (IV)
    for (let bar = 9; bar <= 12; bar++) {
      this.generateBar(bar, {
        groove: true,
        drill: 0,
        gate: false,
        fills: false,
        harmonicChord: { root: 65, type: "major" }, // F major (IV)
        harmonicFunction: "subdominant",
        expectedTension: 0.17, // 0.1 rhythmic + 0.2 harmonic (subdominant)
      });
    }

    // Bars 13-16: Back to tonic, fill at bar 16
    for (let bar = 13; bar <= 16; bar++) {
      this.generateBar(bar, {
        groove: true,
        drill: bar === 16 ? 0.3 : 0,
        gate: false,
        fills: bar === 16,
        harmonicChord: { root: 60, type: "major7" }, // Cmaj7 for color
        harmonicFunction: "tonic",
        expectedTension: bar === 16 ? 0.24 : 0.16,
      });
    }
  }

  /**
   * SECTION B: Interference (Bars 17-32)
   *
   * Purpose: Prove resultants + phase + orthogonal motion
   * Constraints: tension rises 0.3 → 0.7
   */
  private generateSectionB(): void {
    // Bars 17-20: Drill fills at phrase ends, V-IV-iii-vi progression
    for (let bar = 17; bar <= 20; bar++) {
      const isPhraseEnd = bar % 4 === 0;
      const drillAmount = isPhraseEnd ? 0.3 + (bar - 17) * 0.05 : 0;

      // Chord progression: V - IV - iii - vi
      const chords = [
        { root: 67, type: "dominant7" as const }, // G7 (V)
        { root: 65, type: "major7" as const }, // Fmaj7 (IV)
        { root: 64, type: "minor7" as const }, // Em7 (iii)
        { root: 57, type: "minor7" as const }, // Am7 (vi)
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "dominant",
        "subdominant",
        "tonic",
        "tonic",
      ];

      this.generateBar(bar, {
        groove: true,
        drill: drillAmount,
        gate: false,
        fills: isPhraseEnd,
        phase: false,
        harmonicChord: chords[bar - 17],
        harmonicFunction: functions[bar - 17],
        expectedTension: isPhraseEnd ? 0.35 : 0.3,
        cause: isPhraseEnd ? "drill_fill_phrase_end" : "groove_stable",
      });
    }

    // Bars 21-24: Prime grids enabled, ii-V-I-vi progression
    for (let bar = 21; bar <= 24; bar++) {
      const isPhraseEnd = bar % 4 === 0;

      // Chord progression: ii - V - I - vi
      const chords = [
        { root: 62, type: "minor7" as const }, // Dm7 (ii)
        { root: 67, type: "dominant7" as const }, // G7 (V)
        { root: 60, type: "major7" as const }, // Cmaj7 (I)
        { root: 57, type: "minor7" as const }, // Am7 (vi)
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "subdominant",
        "dominant",
        "tonic",
        "tonic",
      ];

      this.generateBar(bar, {
        groove: true,
        drill: 0.4 + (bar - 21) * 0.05,
        gate: false,
        fills: isPhraseEnd,
        resultants: true,
        harmonicChord: chords[bar - 21],
        harmonicFunction: functions[bar - 21],
        expectedTension: 0.45,
        cause: "resultant_interference",
      });
    }

    // Bars 25-28: Hat phase drift enabled, chromatic mediants
    for (let bar = 25; bar <= 28; bar++) {
      // Enable phase drift on hats
      if (bar === 25) {
        this.phase.setDriftRate("hats", 0.0625); // 1/16 note per bar
      }

      // Advance phase each bar
      this.phase.advancePhase("hats");

      const isPhraseEnd = bar % 4 === 0;
      const phaseTension = this.phase.getPhaseTension("hats");

      // Chromatic mediants for tension
      const chords = [
        { root: 63, type: "augmented" as const }, // Eb+ (chromatic mediant)
        { root: 64, type: "minor7" as const }, // Em7
        { root: 66, type: "dominant7" as const, alterations: [5] }, // G7#5
        { root: 60, type: "major7" as const }, // Cmaj7
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "dominant",
        "tonic",
        "dominant",
        "tonic",
      ];

      this.generateBar(bar, {
        groove: true,
        drill: 0.5 + (bar - 25) * 0.05,
        gate: false,
        fills: isPhraseEnd,
        phase: true,
        harmonicChord: chords[bar - 25],
        harmonicFunction: functions[bar - 25],
        expectedTension: 0.5 + phaseTension,
        cause: "phase_drift_accumulating",
      });
    }

    // Bars 29-32: Drill fills intensify, back to ii-V-I
    for (let bar = 29; bar <= 32; bar++) {
      const isPhraseEnd = bar === 32;
      const phaseTension = this.phase.getPhaseTension("hats");

      // ii - V - I - I
      const chords = [
        { root: 62, type: "minor7" as const }, // Dm7
        { root: 67, type: "dominant7" as const }, // G7
        { root: 60, type: "major7" as const }, // Cmaj7
        { root: 60, type: "major7" as const }, // Cmaj7
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "subdominant",
        "dominant",
        "tonic",
        "tonic",
      ];

      this.generateBar(bar, {
        groove: true,
        drill: 0.6 + (bar - 29) * 0.1,
        gate: false,
        fills: isPhraseEnd,
        phase: true,
        harmonicChord: chords[bar - 29],
        harmonicFunction: functions[bar - 29],
        expectedTension: 0.65 + phaseTension,
        cause: "drill_intensifying",
      });

      // Reset phase at section boundary
      if (bar === 32) {
        this.phase.resetPhase("hats");
        this.addEvent(
          bar,
          4,
          "hats",
          "phase_reset",
          {
            phaseOffset: 0,
          },
          "phase_reset_section_boundary",
        );
      }
    }
  }

  /**
   * SECTION C: Collapse (Bars 33-48)
   *
   * Purpose: Prove silence is structural, not absence
   * Constraints: tension.total ≥ 0.85
   */
  private generateSectionC(): void {
    // Bars 33-36: Silence gating begins with secondary dominants
    for (let bar = 33; bar <= 36; bar++) {
      const gateActive = bar >= 33;

      // Secondary dominants creating tension
      const chords = [
        { root: 62, type: "dominant7" as const }, // D7 (V/V)
        { root: 64, type: "dominant7" as const }, // E7 (V/vi)
        { root: 65, type: "dominant7" as const }, // F7 (V/IV)
        { root: 67, type: "dominant7" as const, extensions: [13] }, // G13
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "dominant",
        "dominant",
        "dominant",
        "dominant",
      ];

      this.generateBar(bar, {
        groove: true,
        drill: 0.7 + (bar - 33) * 0.05,
        gate: gateActive,
        fills: false,
        harmonicChord: chords[bar - 33],
        harmonicFunction: functions[bar - 33],
        expectedTension: 0.75,
        cause: "gate_silence_creates_tension",
      });
    }

    // Bars 37-40: Silence → burst replacement with tritone subs
    for (let bar = 37; bar <= 40; bar++) {
      const isBurstBar = bar % 2 === 0;

      // Tritone substitutions for maximum tension
      const chords = [
        { root: 66, type: "dominant7" as const, alterations: [1, 5] }, // G#7#5#9 (tritone sub of D7)
        { root: 62, type: "dominant7" as const, alterations: [1, 5] }, // Db7#5#9 (tritone sub of G7)
        { root: 63, type: "dominant7" as const, alterations: [1, 5] }, // Eb7#5#9
        { root: 60, type: "dominant7" as const, alterations: [1, 5] }, // C7#5#9 (tritone sub of F#7)
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "dominant",
        "dominant",
        "dominant",
        "dominant",
      ];

      this.generateBar(bar, {
        groove: !isBurstBar,
        drill: isBurstBar ? 0.95 : 0.8,
        gate: true,
        fills: isBurstBar,
        harmonicChord: chords[bar - 37],
        harmonicFunction: functions[bar - 37],
        expectedTension: isBurstBar ? 0.9 : 0.82,
        cause: isBurstBar ? "drill_burst_post_silence" : "gate_silence",
      });
    }

    // Bars 41-44: Max drill + gate + diminished7th chords
    for (let bar = 41; bar <= 44; bar++) {
      // Diminished 7th chords for maximum harmonic tension
      const chords = [
        { root: 61, type: "diminished7" as const }, // C#dim7
        { root: 62, type: "diminished7" as const }, // Ddim7
        { root: 63, type: "diminished7" as const }, // Ebdim7
        { root: 64, type: "halfDiminished" as const, extensions: [11] }, // Em7b5add11
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "dominant",
        "dominant",
        "dominant",
        "dominant",
      ];

      this.generateBar(bar, {
        groove: false,
        drill: 0.95,
        gate: true,
        fills: true,
        harmonicChord: chords[bar - 41],
        harmonicFunction: functions[bar - 41],
        expectedTension: 0.88,
        cause: "peak_tension_section_c",
      });
    }

    // Bars 45-48: Peak tension, holding pattern with fully altered
    for (let bar = 45; bar <= 48; bar++) {
      // Fully altered dominants (7#5#9#11 or 7b5b9b11)
      const chords = [
        { root: 67, type: "dominant7" as const, alterations: [1, 5, 8] }, // G7alt
        { root: 65, type: "dominant7" as const, alterations: [1, 5, 8] }, // F7alt
        { root: 63, type: "dominant7" as const, alterations: [1, 5, 8] }, // Eb7alt
        { root: 62, type: "dominant7" as const, alterations: [1, 5, 8] }, // D7alt
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "dominant",
        "dominant",
        "dominant",
        "dominant",
      ];

      this.generateBar(bar, {
        groove: false,
        drill: 0.95,
        gate: true,
        fills: true,
        harmonicChord: chords[bar - 45],
        harmonicFunction: functions[bar - 45],
        expectedTension: 0.9,
        cause: "tension_plateau",
      });
    }
  }

  /**
   * SECTION A': Resolution (Bars 49-64)
   *
   * Purpose: Prove system resolves itself automatically
   * Constraints: tension → < 0.3
   */
  private generateSectionAprime(): void {
    // Bars 49-52: Gate disabled automatically, V-I progression
    for (let bar = 49; bar <= 52; bar++) {
      // Resolution logic: if tension > 0.8, disable gate
      const currentTension = this.tension.getTotal();
      const disableGate = currentTension > 0.8;

      // V - I resolution
      const chords = [
        { root: 67, type: "dominant7" as const }, // G7 (V)
        { root: 60, type: "major" as const }, // C (I)
        { root: 60, type: "major7" as const }, // Cmaj7
        { root: 60, type: "major" as const }, // C
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "dominant",
        "tonic",
        "tonic",
        "tonic",
      ];

      this.generateBar(bar, {
        groove: true,
        drill: disableGate ? 0.4 : 0.7,
        gate: !disableGate,
        fills: false,
        harmonicChord: chords[bar - 49],
        harmonicFunction: functions[bar - 49],
        expectedTension: disableGate ? 0.35 : 0.5,
        cause: disableGate ? "gate_disabled_automatic" : "resolution_early",
      });
    }

    // Bars 53-56: Drill disabled, plagal cadence (IV-I)
    for (let bar = 53; bar <= 56; bar++) {
      const currentTension = this.tension.getTotal();
      const disableDrill = currentTension > 0.5;

      // IV - IV - I - I
      const chords = [
        { root: 65, type: "major7" as const }, // Fmaj7 (IV)
        { root: 65, type: "major7" as const }, // Fmaj7 (IV)
        { root: 60, type: "major7" as const }, // Cmaj7 (I)
        { root: 60, type: "major" as const }, // C (I)
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "subdominant",
        "subdominant",
        "tonic",
        "tonic",
      ];

      this.generateBar(bar, {
        groove: true,
        drill: disableDrill ? 0.1 : 0.4,
        gate: false,
        fills: false,
        harmonicChord: chords[bar - 53],
        harmonicFunction: functions[bar - 53],
        expectedTension: disableDrill ? 0.22 : 0.35,
        cause: disableDrill
          ? "drill_disabled_tension_resolved"
          : "resolution_continuing",
      });
    }

    // Bars 57-60: Groove restored, tonic area
    for (let bar = 57; bar <= 60; bar++) {
      this.generateBar(bar, {
        groove: true,
        drill: 0.15,
        gate: false,
        fills: false,
        harmonicChord: { root: 60, type: "major7" }, // Cmaj7
        harmonicFunction: "tonic",
        expectedTension: 0.2,
        cause: "groove_restored",
      });
    }

    // Bars 61-64: Final cadence, ii-V-I
    for (let bar = 61; bar <= 64; bar++) {
      // ii - V - I - I
      const chords = [
        { root: 62, type: "minor7" as const }, // Dm7 (ii)
        { root: 67, type: "dominant7" as const }, // G7 (V)
        { root: 60, type: "major7" as const }, // Cmaj7 (I)
        { root: 60, type: "major" as const }, // C (I) final
      ];
      const functions: ("tonic" | "subdominant" | "dominant")[] = [
        "subdominant",
        "dominant",
        "tonic",
        "tonic",
      ];

      this.generateBar(bar, {
        groove: true,
        drill: 0,
        gate: false,
        fills: bar === 64,
        harmonicChord: chords[bar - 61],
        harmonicFunction: functions[bar - 61],
        expectedTension: bar === 64 ? 0.14 : 0.22,
        formalTension: bar === 64 ? 0.2 : 0.1,
        cause: bar === 64 ? "final_cadence" : "resolution_approaching",
      });
    }
  }

  /**
   * Generate a single bar with the specified parameters
   */
  private generateBar(
    barNumber: number,
    params: {
      groove: boolean;
      drill: number;
      gate: boolean;
      fills?: boolean;
      phase?: boolean;
      resultants?: boolean;
      expectedTension: number;
      harmonicTension?: number;
      harmonicChord?: ChordQuality;
      harmonicFunction?: "tonic" | "subdominant" | "dominant";
      formalTension?: number;
      cause?: string;
    },
  ): void {
    // Update position
    this.tension.updatePosition(barNumber, 1);
    this.phase.updatePosition(barNumber, 1);

    // Write rhythmic tensions (combine drill and gate)
    const rhythmicTensions: number[] = [];
    const rhythmicCauses: string[] = [];

    if (params.drill > 0) {
      rhythmicTensions.push(params.drill);
      rhythmicCauses.push(params.cause || `drill_bar_${barNumber}`);
    }

    if (params.gate) {
      rhythmicTensions.push(0.8);
      rhythmicCauses.push("gate_silence");
    }

    // Use maximum of drill and gate (they don't stack, gate dominates)
    if (rhythmicTensions.length > 0) {
      const maxRhythmic = Math.max(...rhythmicTensions);
      const cause = rhythmicCauses.join("_and_");
      this.tension.writeRhythmicTension(maxRhythmic, cause);
    }

    // Write harmonic tension (either direct value or analyze chord)
    if (params.harmonicChord && params.harmonicFunction) {
      this.harmonic.writeHarmonicTension(
        params.harmonicChord,
        params.harmonicFunction,
        this.tension,
      );
    } else if (params.harmonicTension !== undefined) {
      this.tension.writeHarmonicTension(
        params.harmonicTension,
        params.cause || `harmony_bar_${barNumber}`,
      );
    }

    if (params.formalTension !== undefined) {
      this.tension.writeFormalTension(
        params.formalTension,
        params.cause || `form_bar_${barNumber}`,
      );
    }

    // Generate musical events for each role
    const roles = ["kick", "snare", "hats", "perc", "bass", "pad"];

    for (const role of roles) {
      this.generateRoleEvents(barNumber, role, params);
    }

    // Verify tension constraints
    const currentTension = this.tension.getTotal();
    if (params.expectedTension !== undefined) {
      // Allow 10% tolerance
      const tolerance = params.expectedTension * 0.1;
      if (Math.abs(currentTension - params.expectedTension) > tolerance) {
        console.warn(
          `Bar ${barNumber}: Expected tension ${params.expectedTension}, ` +
            `got ${currentTension.toFixed(2)}`,
        );
      }
    }
  }

  /**
   * Generate events for a specific role
   */
  private generateRoleEvents(
    barNumber: number,
    role: string,
    params: {
      groove: boolean;
      drill: number;
      gate: boolean;
      fills?: boolean;
      phase?: boolean;
      resultants?: boolean;
    },
  ): void {
    // Kick: Never drills (temporal anchor)
    if (role === "kick") {
      if (params.groove || params.fills) {
        this.addEvent(
          barNumber,
          1,
          role,
          "note",
          {
            pitch: 36, // C2
            velocity: 100,
            duration: 0.5,
          },
          "kick_temporal_anchor",
        );

        this.addEvent(
          barNumber,
          3,
          role,
          "note",
          {
            pitch: 36,
            velocity: 90,
            duration: 1,
          },
          "kick_temporal_anchor",
        );
      }
      return;
    }

    // Hats: Phase drift in Section B
    if (role === "hats" && params.phase) {
      const phaseOffset = this.phase.getPhase("hats");
      const phaseTension = this.phase.getPhaseTension("hats");

      // Generate hats with phase offset
      for (let beat = 1; beat <= 4; beat++) {
        if (!params.gate) {
          this.addEvent(
            barNumber,
            beat,
            role,
            "note",
            {
              pitch: 42, // Closed hi-hat
              velocity: 70,
              duration: 0.25,
              phaseOffset: phaseOffset,
            },
            `hats_phase_motion_${phaseTension.toFixed(2)}`,
          );
        }
      }
      return;
    }

    // Snare: Carries fills
    if (role === "snare") {
      if (params.groove || params.fills) {
        const velocity = params.fills ? 120 : 100;
        this.addEvent(
          barNumber,
          2,
          role,
          "note",
          {
            pitch: 40,
            velocity: velocity,
            duration: 0.5,
          },
          params.fills ? "snare_fill" : "snare_backbeat",
        );

        this.addEvent(
          barNumber,
          4,
          role,
          "note",
          {
            pitch: 40,
            velocity: params.fills ? 115 : 95,
            duration: 1,
          },
          params.fills ? "snare_fill_end" : "snare_backbeat",
        );
      }
      return;
    }

    // Bass: Stable during chaos
    if (role === "bass") {
      if (params.groove) {
        this.addEvent(
          barNumber,
          1,
          role,
          "note",
          {
            pitch: 36, // C2
            velocity: 90,
            duration: 1,
          },
          "bass_foundation",
        );

        this.addEvent(
          barNumber,
          3,
          role,
          "note",
          {
            pitch: 41, // F2
            velocity: 85,
            duration: 0.5,
          },
          "bass_motion",
        );
      }
      return;
    }

    // Pad: Harmonic field
    if (role === "pad") {
      if (params.groove) {
        this.addEvent(
          barNumber,
          1,
          role,
          "note",
          {
            pitch: 60, // C4
            velocity: 60,
            duration: 4,
          },
          "pad_harmony",
        );
      }
      return;
    }

    // Perc: Resultants in Section B
    if (role === "perc" && params.resultants) {
      const density = params.drill * 0.5;
      this.addEvent(
        barNumber,
        1,
        role,
        "fill",
        {
          density: density,
        },
        `perc_resultant_density_${density.toFixed(2)}`,
      );
    }
  }

  /**
   * Add a musical event to the output
   */
  private addEvent(
    bar: number,
    beat: number,
    role: string,
    type: MusicalEvent["type"],
    properties: MusicalEvent["properties"],
    cause: string,
  ): void {
    const currentTension = this.tension.getCurrent();

    const event: MusicalEvent = {
      bar,
      beat,
      role,
      type,
      properties,
      tension: { ...currentTension },
      cause,
    };

    this.events.push(event);
  }

  /**
   * Get tension history for analysis
   */
  getTensionHistory(): {
    bar: number;
    tension: StructuralTension;
    total: number;
  }[] {
    const snapshots: {
      bar: number;
      tension: StructuralTension;
      total: number;
    }[] = [];

    // Group events by bar
    for (const event of this.events) {
      const existing = snapshots.find((s) => s.bar === event.bar);
      if (!existing) {
        snapshots.push({
          bar: event.bar,
          tension: event.tension,
          total: totalTension(event.tension),
        });
      }
    }

    return snapshots.sort((a, b) => a.bar - b.bar);
  }

  /**
   * Initialize phase tracking for all roles
   */
  private initializeRoles(): void {
    // Kick: Locked (temporal anchor)
    this.phase.registerRole("kick", {
      driftRate: 0,
      locked: true,
    });

    // Snare: No drift
    this.phase.registerRole("snare", {
      driftRate: 0,
      locked: false,
    });

    // Hats: Will drift in Section B
    this.phase.registerRole("hats", {
      driftRate: 0,
      maxOffset: 0.25,
    });

    // Perc: No drift
    this.phase.registerRole("perc", {
      driftRate: 0,
    });

    // Bass: Locked (stability anchor)
    this.phase.registerRole("bass", {
      driftRate: 0,
      locked: true,
    });

    // Pad: No phase
    this.phase.registerRole("pad", {
      driftRate: 0,
    });
  }
}

/**
 * Generate and validate the demo piece
 */
export function generateDemoPiece(config?: Partial<DemoPieceConfig>): {
  events: MusicalEvent[];
  tensionHistory: { bar: number; tension: StructuralTension; total: number }[];
  validation: {
    totalBars: number;
    tensionConstraintsMet: boolean;
    sectionStructure: { [key: string]: { start: number; end: number } };
  };
} {
  const generator = new DemoPieceGenerator(config);
  const events = generator.generate();
  const tensionHistory = generator.getTensionHistory();

  // Validate structure
  const validation = {
    totalBars: 64,
    tensionConstraintsMet: true,
    sectionStructure: {
      A_STABILITY: { start: 1, end: 16 },
      B_INTERFERENCE: { start: 17, end: 32 },
      C_COLLAPSE: { start: 33, end: 48 },
      A_RESOLUTION: { start: 49, end: 64 },
    },
  };

  return {
    events,
    tensionHistory,
    validation,
  };
}
