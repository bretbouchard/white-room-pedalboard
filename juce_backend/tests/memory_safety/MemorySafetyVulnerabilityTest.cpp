/*
  ==============================================================================
    MemorySafetyVulnerabilityTest.cpp

    RED phase tests that demonstrate memory safety violations in audio components.
    These tests are designed to FAIL to expose vulnerabilities before fixes.
  ==============================================================================
*/

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <thread>
#include <chrono>
#include <vector>
#include <atomic>

// Mock audio components that reproduce the vulnerability patterns found in the codebase
class MockAudioNode {
public:
    std::unique_ptr<float[]> audioBuffer;
    size_t bufferSize;
    std::atomic<bool> processing{false};

    MockAudioNode(size_t size) : bufferSize(size), audioBuffer(std::make_unique<float[]>(size)) {}
    ~MockAudioNode() = default;

    void process() {
        processing = true;
        std::fill(audioBuffer.get(), audioBuffer.get() + bufferSize, 0.0f);

        // Simulate audio processing time
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        processing = false;
    }

    float* getBuffer() { return audioBuffer.get(); }
};

class MockAudioGraph {
private:
    std::vector<std::unique_ptr<MockAudioNode>> nodes;
    std::vector<MockAudioNode*> rawNodePtrs;  // VULNERABILITY: Raw pointers to managed objects

public:
    ~MockAudioGraph() {
        // VULNERABILITY: No proper cleanup order - raw pointers may dangle
    }

    void addNode(std::unique_ptr<MockAudioNode> node) {
        rawNodePtrs.push_back(node.get());  // VULNERABILITY: Storing raw pointer
        nodes.push_back(std::move(node));
    }

    // VULNERABILITY: Use-after-free during node removal while processing
    void removeNodeDuringProcessing(size_t index) {
        if (index < nodes.size()) {
            auto& node = nodes[index];

            // Start processing in background thread
            std::thread processor(&MockAudioNode::process, node.get());

            // DANGER: Remove node while it might still be processing
            nodes.erase(nodes.begin() + index);
            rawNodePtrs.erase(rawNodePtrs.begin() + index);

            processor.join();  // Node might be accessing freed memory
        }
    }

    void processAllNodes() {
        // VULNERABILITY: Use raw pointers that might be dangling
        for (auto* rawNode : rawNodePtrs) {
            if (rawNode) {  // This check is insufficient
                rawNode->process();  // POTENTIAL USE-AFTER-FREE
            }
        }
    }

    MockAudioNode* getRawNode(size_t index) {
        return rawNodePtrs[index];  // VULNERABILITY: Returning dangling raw pointer
    }
};

class MockPersistenceManager {
private:
    std::vector<std::unique_ptr<char[]>> managedBuffers;
    std::vector<char*> rawBuffers;  // VULNERABILITY: Raw pointers to managed memory
    std::atomic<bool> cleanupInProgress{false};

public:
    ~MockPersistenceManager() {
        cleanup();
    }

    void addDataBuffer(size_t size) {
        auto buffer = std::make_unique<char[]>(size);
        char* rawPtr = buffer.get();

        managedBuffers.push_back(std::move(buffer));
        rawBuffers.push_back(rawPtr);  // VULNERABILITY: Storing raw pointer
    }

    // VULNERABILITY: Double-free potential through concurrent cleanup
    void cleanup() {
        if (cleanupInProgress.exchange(true)) {
            return;  // Prevent concurrent cleanup attempts
        }

        // Clear raw pointers first
        rawBuffers.clear();

        // Clear managed buffers
        managedBuffers.clear();

        cleanupInProgress = false;
    }

    // VULNERABILITY: Access to potentially freed memory
    char* getRawBuffer(size_t index) {
        if (index < rawBuffers.size()) {
            return rawBuffers[index];  // Might be dangling
        }
        return nullptr;
    }

    // VULNERABILITY: Race condition during buffer access
    void writeToBufferConcurrently(size_t index, const char* data, size_t size) {
        if (index >= rawBuffers.size()) return;

        char* buffer = rawBuffers[index];  // Get raw pointer

        // Start cleanup in background
        std::thread cleanupThread(&MockPersistenceManager::cleanup, this);

        // Write to buffer - might be accessing freed memory
        if (buffer && data) {
            std::memcpy(buffer, data, size);  // POTENTIAL USE-AFTER-FREE
        }

        cleanupThread.join();
    }
};

//==============================================================================
// Memory Safety Vulnerability Tests - RED Phase (These tests MUST fail)

class MemorySafetyVulnerabilityTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Enable AddressSanitizer for detection (if available)
        #ifdef __has_feature
            #if __has_feature(address_sanitizer)
            // ASan is enabled - these tests should detect violations
            #endif
        #endif
    }

    void TearDown() override {
        // Force garbage collection to trigger potential use-after-free
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
};

// Test 1: Use-after-free in AudioGraph node removal during processing
TEST_F(MemorySafetyVulnerabilityTest, UseAfterFreeInAudioGraphNodeRemoval) {
    auto graph = std::make_unique<MockAudioGraph>();

    // Add multiple nodes
    for (int i = 0; i < 5; ++i) {
        graph->addNode(std::make_unique<MockAudioNode>(1024));
    }

    // Get raw pointer to node before removal
    MockAudioNode* rawNodePtr = graph->getRawNode(2);
    ASSERT_NE(rawNodePtr, nullptr);

    // This should trigger use-after-free
    graph->removeNodeDuringProcessing(2);

    // Try to access the removed node - this demonstrates the vulnerability
    // In a real scenario, this would crash or cause undefined behavior
    EXPECT_DEATH({
        rawNodePtr->process();  // Accessing potentially freed memory
    }, ".*");
}

// Test 2: Double-free vulnerability in persistence manager
TEST_F(MemorySafetyVulnerabilityTest, DoubleFreeInPersistenceManager) {
    auto manager = std::make_unique<MockPersistenceManager>();

    // Add some data buffers
    manager->addDataBuffer(1024);
    manager->addDataBuffer(2048);
    manager->addDataBuffer(4096);

    // Get raw pointer to buffer
    char* rawBuffer = manager->getRawBuffer(1);
    ASSERT_NE(rawBuffer, nullptr);

    // Trigger concurrent cleanup that might cause double-free
    std::thread cleanup1(&MockPersistenceManager::cleanup, manager.get());
    std::thread cleanup2(&MockPersistenceManager::cleanup, manager.get());

    cleanup1.join();
    cleanup2.join();

    // Try to write to the potentially freed buffer
    EXPECT_DEATH({
        const char testData[] = "test data";
        manager->writeToBufferConcurrently(1, testData, sizeof(testData));
    }, ".*");
}

// Test 3: Buffer overflow in audio processing
TEST_F(MemorySafetyVulnerabilityTest, BufferOverflowInAudioProcessing) {
    auto node = std::make_unique<MockAudioNode>(1024);

    // This should cause buffer overflow
    EXPECT_DEATH({
        float* buffer = node->getBuffer();
        // Write beyond buffer bounds
        for (int i = 0; i < 2048; ++i) {  // Double the buffer size
            buffer[i] = static_cast<float>(i);  // BUFFER OVERFLOW
        }
    }, ".*");
}

// Test 4: Memory leak from improper cleanup
TEST_F(MemorySafetyVulnerabilityTest, MemoryLeakFromImproperCleanup) {
    // This test would need memory leak detection
    // In real usage, run with leak sanitizer: LSAN_OPTIONS=detect_leaks=1

    std::vector<std::unique_ptr<char[]>> leakyBuffers;

    // Create buffers without proper cleanup
    for (int i = 0; i < 100; ++i) {
        leakyBuffers.push_back(std::make_unique<char[]>(1024 * 1024));  // 1MB each
    }

    // Deliberately "lose" some buffers
    leakyBuffers.resize(50);  // 50 buffers leaked

    // This test would require leak detection tools to properly validate
    SUCCEED();  // Placeholder - real test would use memory leak detection
}

// Test 5: Data race in concurrent audio processing
TEST_F(MemorySafetyVulnerabilityTest, DataRaceInConcurrentProcessing) {
    auto graph = std::make_unique<MockAudioGraph>();

    // Add a node
    graph->addNode(std::make_unique<MockAudioNode>(1024));

    // Start processing in multiple threads
    std::vector<std::thread> processors;
    for (int i = 0; i < 10; ++i) {
        processors.emplace_back([&graph]() {
            for (int j = 0; j < 100; ++j) {
                graph->processAllNodes();  // Concurrent access to same resources
            }
        });
    }

    // Remove nodes while processing is happening
    std::thread remover([&graph]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        if (graph->getRawNode(0)) {
            // This should cause data race/use-after-free
            graph->removeNodeDuringProcessing(0);
        }
    });

    for (auto& thread : processors) {
        thread.join();
    }
    remover.join();

    // If we reach here without crashing, it doesn't mean the code is safe
    SUCCEED();  // Real validation would use ThreadSanitizer
}

// Test 6: Invalid memory access in cleanup
TEST_F(MemorySafetyVulnerabilityTest, InvalidMemoryAccessInCleanup) {
    auto manager = std::make_unique<MockPersistenceManager>();

    // Add buffers
    manager->addDataBuffer(1024);
    manager->addDataBuffer(2048);

    // Get raw pointers
    char* buffer1 = manager->getRawBuffer(0);
    char* buffer2 = manager->getRawBuffer(1);

    // Clear managed buffers (frees memory)
    manager->cleanup();

    // Try to access freed memory
    EXPECT_DEATH({
        // These accesses should crash with address sanitizer
        buffer1[0] = 'x';  // WRITE-AFTER-FREE
        char dummy = buffer2[0];  // READ-AFTER-FREE
        (void)dummy;  // Avoid unused variable warning
    }, ".*");
}

// Test 7: Circular reference with shared_ptr (memory leak)
TEST_F(MemorySafetyVulnerabilityTest, CircularReferenceMemoryLeak) {
    struct Node;
    using NodePtr = std::shared_ptr<Node>;

    struct Node {
        NodePtr parent;
        std::vector<NodePtr> children;
        std::unique_ptr<float[]> audioData;

        Node() : audioData(std::make_unique<float[]>(1024)) {}

        void addChild(NodePtr child) {
            children.push_back(child);
            child->parent = shared_from_this();  // Creates circular reference
        }
    };

    auto parent = std::make_shared<Node>();
    auto child = std::make_shared<Node>();

    // Create circular reference - memory will never be freed
    parent->addChild(child);

    // These should be cleaned up when they go out of scope,
    // but the circular reference prevents cleanup
    EXPECT_EQ(parent.use_count(), 2);  // parent + child's parent reference
    EXPECT_EQ(child.use_count(), 2);   // child + parent's children reference

    // When parent and child go out of scope, memory is leaked due to circular reference
    SUCCEED();  // Real validation would use weak_ptr or leak detection
}

//==============================================================================
// Performance impact test - demonstrate overhead of memory safety violations

TEST_F(MemorySafetyVulnerabilityTest, PerformanceImpactOfMemorySafetyIssues) {
    auto startTime = std::chrono::high_resolution_clock::now();

    {
        auto graph = std::make_unique<MockAudioGraph>();

        // Create many nodes
        for (int i = 0; i < 1000; ++i) {
            graph->addNode(std::make_unique<MockAudioNode>(1024));
        }

        // Perform operations with potential memory safety issues
        for (int i = 0; i < 100; ++i) {
            graph->processAllNodes();

            // Remove nodes randomly (potential use-after-free)
            if (i % 10 == 0 && graph->getRawNode(0)) {
                graph->removeNodeDuringProcessing(0);
            }
        }
    }

    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);

    // Memory safety issues cause performance degradation
    EXPECT_LT(duration.count(), 5000);  // Should complete within 5 seconds

    // Log performance impact
    std::cout << "Performance with memory safety issues: " << duration.count() << "ms" << std::endl;
}

/*
  NOTE: These tests are designed to FAIL and demonstrate memory safety vulnerabilities.

  To run with sanitizers (recommended):

  AddressSanitizer (detects use-after-free, buffer overflow):
  g++ -fsanitize=address -g -o memory_test MemorySafetyVulnerabilityTest.cpp -lgtest -lgtest_main -pthread

  ThreadSanitizer (detects data races):
  g++ -fsanitize=thread -g -o memory_test MemorySafetyVulnerabilityTest.cpp -lgtest -lgtest_main -pthread

  MemorySanitizer (detects uninitialized reads):
  g++ -fsanitize=memory -g -o memory_test MemorySafetyVulnerabilityTest.cpp -lgtest -lgtest_main -pthread

  UndefinedBehaviorSanitizer:
  g++ -fsanitize=undefined -g -o memory_test MemorySafetyVulnerabilityTest.cpp -lgtest -lgtest_main -pthread

  LeakSanitizer (detects memory leaks, included with AddressSanitizer):
  LSAN_OPTIONS=detect_leaks=1 ./memory_test

  For comprehensive testing:
  export UBSAN_OPTIONS=print_stacktrace=1
  export ASAN_OPTIONS=detect_leaks=1:strict_string_checks=1:detect_stack_use_after_return=1
  ./memory_test
*/